## **一、单一职责原则（SRP）** {#一单一职责原则srp}

**定义：**不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。  
**问题由来：**类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。  
**解决方案：**遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。

遵循单一职责原的优点有：  
 1. 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；  
 2. 提高类的可读性，提高系统的可维护性；  
 3. 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。

需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都需要遵循这一重要原则。

## **二、开闭原则（OCP）** {#二开闭原则ocp}

**定义：**一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。  
**问题由来：**在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。  
**解决方案：**当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。

## **三、里氏替换原则（LSP）** {#三里氏替换原则lsp}

**定义1：**如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。  
**定义2：**所有引用基类的地方必须能透明地使用其子类的对象。  
**问题由来：**有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。  
**解决方案：**当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。

里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：  
 1. 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。  
 2. 子类中可以增加自己特有的方法。  
 3. 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。  
 4. 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

## **四、接口隔离原则（ISP）** {#四接口隔离原则isp}

**定义：**客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。  
**问题由来：**类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。  
**解决方案：**将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。

很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。

采用接口隔离原则对接口进行约束时，要注意以下几点：  
 1. 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。  
 2. 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。  
 3. 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。

运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。

## **五、依赖倒置原则（DIP）\*** {#五依赖倒置原则dip}

**定义：**高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。  
**问题由来：**类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。  
**解决方案：**将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。

传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过[spring](http://lib.csdn.net/base/17)框架的，对依赖的传递方式一定不会陌生。

在实际编程中，我们一般需要做到如下3点：  
 1.低层模块尽量都要有抽象类或接口，或者两者都有。  
 2.变量的声明类型尽量是抽象类或接口。  
 3.使用继承时遵循里氏替换原则。

依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。

## **附、迪米特法则** {#附迪米特法则}

**定义：**一个对象应该对其他对象保持最少的了解。  
**问题由来：**类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。  
**解决方案：**尽量降低类与类之间的耦合。

## **总述：** {#总述}

* 单一职责原则告诉我们实现类要职责单一；
* 里氏替换原则告诉我们不要破坏继承体系；
* 依赖倒置原则告诉我们要面向接口编程；
* 接口隔离原则告诉我们在设计接口的时候要精简单一；
* 开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。
* 迪米特法则告诉我们要降低耦合。



