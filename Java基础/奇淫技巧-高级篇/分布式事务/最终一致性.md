对于分布式框架而言，从功能上需要支持分布式事务，但是在实际的使用过程中，如果能通过最终一致性解决问题，则不需要做强一致性；如果能避免分布式事务，则在业务层避免使用分布式事务。

型的问题是微服务之间如果需要共享状态怎么办？实际是在[**分布式**](http://www.jdon.com/DistributedSystems.html)节点之间需要共享或复制状态。关于共享状态有几个解决方案：  
1.微服务之间通过共享同一个数据库实现状态共享，但是因为微服务是使用自己专用的数据库，因此，数据库共享方案在微服务中是不适用的，违背了微服务架构宗旨。

2.通过调用同一个微服务实现状态共享，比如A服务和B服务需要共享C数据状态，而C数据状态是由C服务管理的，那么，A服务和B服务共同调用C服务不就是获得同一个C状态吗？  
但是考虑到[**分布式**](http://www.jdon.com/DistributedSystems.html)系统下，A服务和B服务可能不在同一个节点服务器上，或者不同Docker VM中，那么服务之间调用就需要网络通讯，通常RPC是一种通过网络调用远程服务器上其他服务的同步方式，但是，RPC虽然将网络编程藏起来，其实藏是藏不住，结果造成抽象泄漏了。

"Asynch message-passing makes constraints of network programming firstclass instead of hiding them behind the RPC leaky abstraction"异步消息传递使得网络编程变成第一公民\(显式\)，而不是像RPC隐藏了网络编程却造成抽象泄漏。

在[**分布式**](http://www.jdon.com/DistributedSystems.html)系统中使用异步消息必然会遭遇最终一致性。甚至可以说微服务是使用最终一致性的\(microservices use eventual consistency\)

# **最终一致性Eventual Consistency** {#body_23147210}

最终一致性是一种用于描述在[**分布式**](http://www.jdon.com/DistributedSystems.html)系统中数据的操作模型，在[**分布式**](http://www.jdon.com/DistributedSystems.html)系统中状态是被复制然后跨网络多节点保存，其实在关系数据库集群中，最终一致性被用来在集群多个节点之间协调数据复制的写操作，数据库集群中这种写操作挑战是：各个节点接受到的写操作必须严格按照复制的次序进行，这个次序是有时间损耗的，从这个角度看，数据库在集群节点之间的这种状态复制还是可以被认为是一种最终一致性，所有节点状态在未来某个时刻最终汇聚到一个一致性状态，也就是说，最终达成状态一致性。  当构建微服务时，最终一致性是开发者 DBA和架构师频繁打交道的问题，当开始在[**分布式**](http://www.jdon.com/DistributedSystems.html)系统中进行状态处理时，头疼问题更加严重。核心问题是：  如何在保证数据一致性基础上保证高可用性呢？

# **事务日志** {#body_23147210}



