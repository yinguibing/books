```
client代码：
```

```java
public static void main\(String\[\] args\) {

    HelloService helloServiceImpl = new HelloServiceImpl\(\) ;



    Class cls = helloServiceImpl.getClass\(\) ;

    HelloService proxy = \(HelloService\) Proxy.newProxyInstance\(cls.getClassLoader\(\), cls.getInterfaces\(\), new HelloInvocationHanlerImpl\(helloServiceImpl\)\) ;



    proxy.sayHello\(\);

}
```

```
/**
 * 聚合模式
 * @author Administrator
 *
 */
public class HelloInvocationHanlerImpl implements InvocationHandler {

    private Object realObjec ;



    public HelloInvocationHanlerImpl(Object realObjec) {
        super();
        this.realObjec = realObjec;
    }



    /**
     * 
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        System.out.println("方法调用助手类");

        return method.invoke(realObjec, null) ;
    }

}
```

接口类：

```java
public interface HelloService {

    String sayHello() ;



}
```

接口实现类：

```java
public class HelloServiceImpl implements HelloService {

    @Override
    public String sayHello() {

        System.out.println("实现类的helloservice");
        return "实现类的helloservice";
    }

}
```

JDK动态代理解释：

1、proxy类： 通过类加载机制，利用制定的类的加载器加载接口的元数据，产生一个接口的空实现，这个空实现也就是代理类。代理类中会应用invocationhandler的实现；

2、invocationhandler：组合了proxy类和realImpl接口的真正实现类。

3、client掉用proxy的方法，proxy会调用invocationhandler的invoke方法，将proxy自己本省作为入参，同时将method和arg传入，完成代理调用。

